

Here is an example hash from Drupal 7:

"pass" : "$S$Dxl65W9p07LfQU7jvy5CnsyDpMoLujiAgzy123khcg1OJi/P9pKS"

The characters 0-2 are the type ( $S$ is Drupal 7 )

The character 3 is the number of log2 rounds (X) based on the position of the char in this list: './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' So in our example 'D' would map to 15
The characters 4-11 are the SALT
The rest is a SHA512 hash using 2^X rounds.
The binary result is then converted to a string using base64.

$count = 1 << $count_log2;
$hash = hash($algo, $salt . $password, TRUE);
do { $hash = hash($algo, $hash . $password, TRUE);
} while (--$count);

The whole process can be found in: mydrupalsite\includes\password.inc

-------------------------------------------------------------------------------------------

Without using special hardware (and even then, it's debatable), there is no such thing as a truly random number generated by a computer.

That being said; your only problem is: how do you generate your seeds such that two programs will not generate the same number. Using the current time as part of your seed is reasonable, but as you understand, it's not enough because two programs could generate their seed at the same time... so you need to augment your seed based on something that will be unique between the programs. Possibilities include process ID (which will differ if both programs are on the same computer), hardware mac address (which will differ if both programs are on different computers), or timing how long it takes the user to perform some task (which will generally differ as long as the user is human, not automation).

-------------------------------------------------------------------------------------------

n addition of other answers, on Linux (and some other Unix) systems, you could read a few bytes from the /dev/random or /dev/urandom pseudo-device (at least to seed your PNRG). Read also carefully the random(4) man page (which also explains the important difference between /dev/random and /dev/urandom)

If coding for the latest C++2011 standard (and not the previous ones), you could be interested by its <random> header. Then use a very recent GCC compiler (e.g. 4.7) and libstdc++ library




--------------------------------------------------------------------------------------------------

You generally do not want to send the password over the link at all, not even with encryption. The usual method is a challenge-response protocol.

The client connects to the server, sending in the user-name (but not password)
The server responds by sending out unique random number
The client encrypts that random number using the hash of their password as the key
The client sends the encrypted random number to the server
The server encrypts the random number with the correct hash of the user's password
The server compares the two encrypted random numbers
This has a couple of advantages. First, it means the password never goes over the link in any form. Second, it's immune to a replay attack -- if an attacker records the conversation, they can't replay the client's replies later to log in, because the random number will have changed.

Securing the connection (i.e., encrypting the content) is a little simpler. Typically, one of the two (doesn't really matter much which) picks a random number, encrypts it with the other's public key, and sends it to the other. The other decrypts it, and they encrypt the rest of the session using that as a key for symmetric encryption.

Libraries: Beecrypt and OpenSSL are a couple of obvious ones. Unless you have a fairly specific reason to do otherwise, TLS is what you probably want to use (it does quite a bit more than what I've outlined above, including two-way authentication, so not only does the server know who the client is, but the client also knows who the server is, so it's reasonably verified that it's not connected to somebody else who might just collect his credit card number and run with it).

Edit:

To authenticate each packet without the overhead of encrypting everything, you could do something like this:

The server sends its public key with the challenge
The client generates a random number, encrypts it with the server's public key, and sends it back with its response
The number is the first number used for counter-mode encryption
The client includes one counter-mode result with each packet it sends
Counter mode means you just generate consecutive numbers, and encrypt each in turn, using the right key. In this case, the key would be the hash of the client's password. What this means is that each packet will contain a unique random number that both the client and the server can generate, but nobody else can. By using the counter-mode encryption, each packet will have a unique random number. By starting from a random number, each session will have a unique sequence of random numbers.

To minimize overhead, you could send just a part of the result with each packet -- e.g., if you use AES in counter mode, it'll generate 16 bytes of result for each number you encrypt. Include only (say) two bytes of that with each packet, so you only have to encrypt a number once every 8 packets. In theory, this cuts security -- an attacker could just try all 65536 possible values for a packet, but if you assume the connection has been compromised after (say) two bad attempts, the chances of an attacker getting the right value become pretty small (and, of course, you can pretty much pick the chances you're willing to live with by controlling the number of bad attempts you allow and the size of authentication you include in each packet).

